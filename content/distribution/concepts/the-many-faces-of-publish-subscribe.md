title=The many faces of publish/subscribe
tags=distribution, reading, concepts
summary=Notes from the paper.
~~~~~~

[PDF](https://systems.cs.columbia.edu/ds2-class/papers/eugster-pubsub.pdf)

The publish/subscribe interaction paradigm provides subscribers with the ability to express their interest in an event or a pattern of events, in order to be notified subsequently of any event, generated by a publisher, that matches their registered interest. In other terms, producers publish information on a software bus (an event manager) and consumers subscribe to the information they want to receive from that bus. This information is typically denoted by the term event and the act of delivering it by the term notification.

The basic system model for publish/subscribe interaction relies on an event notification service providing storage and management for subscriptions and efficient delivery of events. Such an event service represents a neutral mediator between publishers, acting as producers of events, and subscribers, acting as consumers of events. Subscribers register their interest in events by typically calling a subscribe() operation on the event service, without knowing the effective sources of these events. This subscription information remains stored in the event service and is not forwarded to publishers. The symmetric operation unsubscribe() terminates a subscription. 

To generate an event, a publisher typically calls a publish() operation. The event service propagates the event to all relevant subscribers; it can thus be viewed as a proxy for the subscribers. Note that every subscriber will be notified of every event conforming to its interest (obviously, failures might prevent subscribers from receiving some events). Publishers also often have the ability to advertise the nature of their future events through an advertise() operation. The provided information can be useful for (1) the event service to adjust itself to the expected flows of events, and (2) the subscribers to learn when a new type of information becomes available. The decoupling that the event service provides between publishers and subscribers can be decomposed along the following three dimensions:

* Space decoupling: The interacting parties do not need to know each other. The publishers publish events through an event service and the subscribers get these events indirectly through the event service. The publishers do not usually hold references to the subscribers, neither do they know how many of these subscribers are participating in the interaction. Similarly, subscribers do not usually hold references to the publishers, neither do they know how many of these publishers are participating in the interaction.

* Time decoupling: The interacting parties do not need to be actively participating in the interaction at the same time. In particular, the publisher might publish some events while the subscriber is disconnected, and conversely, the subscriber might get notified about the occurrence of some event while the original publisher of the event is disconnected.

* Synchronization decoupling: Publishers are not blocked while producing events, and subscribers can get asynchronously notified (through a callback) of the occurrence of an event while performing some concurrent activity. The production and consumption of events do not happen in the main flow of control of the publishers and subscribers, and do not therefore happen in a synchronous manner.

#### The Cousins: Alternative communication paradigms

**Message Passing.** Message passing can be viewed as the ancestor of distributed interactions. Message passing represents a low-level form of distributed communication, in which participants communicate by simply sending and receiving messages. Although complex interaction schemes are still built on top of such primitives, message passing is nowadays rarely used directly for developing distributed applications, since physical addressing and data marshaling, and sometimes even flow control (e.g., retransmission), become visible to the application layer. Message passing is asynchronous for the producer, while message consumption is generally synchronous. (Message passing interaction: the producer sends messages asynchronously through a communication channel (previously set up for that purpose). The consumer receives messages by listening synchronously on that channel.) The producer and the consumer are coupled both in time and space: they must both be active at the same time and the recipient of a message is known to the sender.

**RPC.** One of the most widely used forms of distributed interaction is the remote invocation, an extension of the notion of “operation invocation” to a distributed context. This type of interaction was first proposed in the form of a remote procedure call (RPC) [Birrell and Nelson 1983; Tay and Ananda 1990] for procedural languages, and has been straightforwardly applied to object-oriented contexts in the form of remote method invocations, for example, in Java RMI [Sun 2000], CORBA [OMG 2002a], Microsoft DCOM [Horstmann and Kirtland 1997; Chung et al. 1998].

(RPC and derivatives: the producer performs a synchronous call, which is processed asynchronously by the consumer.)

By making remote interactions appear the same way as local interactions, the RPC model and its derivatives make distributed programming very easy. This explains their tremendous popularity in distributed computing. Distribution cannot, however, be made completely transparent to the application, because it gives rise to further types of potential failures (e.g., communication failures) that have to be dealt with explicitly. RPC differs from publish/subscribe in terms of coupling: the synchronous nature of RPC introduces a strong time, synchronization (on the consumer side), and also space coupling (since an invoking object holds a remote reference to each of its invokees). (NOTE: The distinction between consumer and producer roles is not straightforward in RPC. We assume here that an RPC that yields a reply attributes a consumer role to the invoker, while the invokee acts as producer. As we will point out, the roles are inverted with asynchronous invocations (which yield no reply).)

(Decoupling synchronization with asynchronous remote invocation: the producer does not expect a reply.)

Several attempts have been made to remove synchronization coupling in remote and avoid blocking the caller thread while waiting for the reply of a remote invocation. A first variant consists in providing a special flavor of asynchronous invocation for remote methods that have no return values, as shown in Figure 5. For instance, CORBA [OMG 2002a] provides a special one-way modifier that can be used to specify such methods. This approach leads to invocations with weak reliability guarantees because the sender does not receive success or failure notifications (this type of interaction is often called *fire-and-forget*). The second, less restrictive variant supports return values, but does not make them directly available to the calling thread. Instead, the result of a remote invocation is a handle through which the actual return values will be accessed when needed. With this approach, known as *future* or *future type message passing* [Yonezawa et al. 1987; Ananda et al. 1992] or *wait-by-necessity* [Caromel 1993], the invoking thread can continue processing and request the return value later, thanks to the handle.

(Decoupling synchronization with future remote invocation: the producer is not blocked and can access the reply later when it becomes available.)

**Notifications.** In order to achieve synchronization decoupling, a synchronous remote invocation is
sometimes split into two asynchronous invocations: the first one sent by the client
to the server—accompanied by the invocation arguments and a callback reference to the client—and the second one
sent by the server to the client to return
the reply. This scheme can be easily extended to return several replies by having the server make several callbacks to
the client. Such notification-based interaction is widely used to ensure consistency
of Web caches [Wessels 1995]: upon download of Web contents, Web proxies receive a
promise to be notified if any change occurs
at the Web server. This implements a limited form of publish/subscribe interaction
in which Web proxies act as subscribers
and the Web server as the publisher.
This type of interaction—where subscribers register their interest directly
with publishers, which manage subscriptions and send events—corresponds to the
so-called observer design pattern [Gamma
et al. 1995]. It is generally implemented using asynchronous invocations in order to enforce synchronization decoupling. Although publishers
notify subscribers asynchronously, they
both remain coupled in time and in space.
Furthermore the communication management is left to the publisher and can become burdensome as the system grows in
size.

( Notifications: producers and consumers communicate using asynchronous invocations flowing in both directions.)

**Shared Spaces.** The distributed shared memory (DSM) paradigm [Li and Hudak 1989; Tam et al. 1990] provides hosts in a distributed system with the view of a common shared space across disjoint address spaces, in which synchronization and communication between participants take place through operations on shared data. The notion of tuple space was originally integrated at the language level in Linda [Gelernter 1985], and provides a simple and powerful abstraction for accessing shared memory. A tuple space is composed of a collection of ordered tuples, equally accessible to all hosts of a distributed system. Communication between hosts takes place through the insertion/removal of tuples into/from the tuple space. Three main operations can be performed: out() to export a tuple into a tuple space, in() to import (and remove) a tuple from the tuple space, and read() to read (without removing) a tuple from the tuple space.

The interaction model provides time and space decoupling, in that tuple producers and consumers remain anonymous with respect to each other. The creator of a tuple needs no knowledge about the future use of that tuple or its destination. An inbased interaction implements one-of-n semantics (only one consumer reads a given tuple) whereas read-based interaction can be used to implement one-to-n message delivery (a given tuple can be read by all such consumers). Unlike the publish subscribe paradigm, the DSM model does not provide synchronization decoupling because consumers pull new tuples from the space in a synchronous style. This limits the scalability of the model due to the required synchronization between the participants. To compensate the lack of synchronization decoupling, some modern tuple space systems like JavaSpaces [Sun 2002], TSpaces [Lehman et al. 1999], and WCL [Rowstron 1998] extend the Linda tuple space model with asynchronous notifications.

A similar communication abstraction, called rendezvous, has been introduced in the Internet Indirection Infrastructure (I3) [Stoica et al. 2002]. Instead of explicitly sending a packet to a destination, each packet is associated with an identifier; this identifier is then used by the receiver to obtain delivery of the packet. This level of indirection decouples the act of sending from the act of receiving.

(Shared space: producers insert data asynchronously into the shared space, while consumers read data synchronously.)

**Message Queuing.** Message queuing [Blakeley et al. 1995] is a more recent alternative for distributed interaction. In fact, the term *message queuing* is often used to refer to a family of products (e.g., IBM Corporation [1995]; Houston [1998]; DEC [1994]; Oracle [2002]) rather than to a specific interaction scheme. Message queuing and publish/subscribe are tightly intertwined: message queuing systems usually integrate some form of publish/subscribelike interaction. Such message-centric
approaches are often referred to as message-oriented middleware (MOM) [Banavar et al. 1999b].

At the interaction level, message queues recall much of tuple spaces: queues can be seen as global spaces, which are fed with messages from producers. From a functional point of view, message queuing systems additionally provide transactional, timing, and ordering guarantees not necessarily considered by tuple spaces.

In message queuing systems, messages are concurrently pulled by consumers with one-of-n semantics similar to those offered by tuple spaces through the `in()` operation. These interaction model is often also referred to as point-to-point (PTP) queuing. Which element is retrieved by a consumer is not defined by the element’s structure, but by the order in which the elements are stored in the queue (generally first-in first-out (FIFO) or priority-based order).

Similarly to tuple spaces, producers and consumers are decoupled in both time and space. As consumers synchronously pull messages, message queues do not provide synchronization decoupling. Some message queuing systems offer limited support for asynchronous message delivery, but these asynchronous mechanisms do not scale well to large populations of consumers because of the additional interactions needed to maintain transactional, timing, and ordering guarantees.

(Message queuing: messages are stored in a FIFO queue. Producers append messages asynchronously at the end of the queue, while consumers dequeue them synchronously at the front of the queue.)

**Summary.**

Abstraction | Space decoupling | Time decoupling | Synchronization decoupling
----------- | ---------------- | --------------- | --------------------------
Message passing | No | No | Producer-side
RPC/RMI | No | No | Producer-side
Asynchronous RPC/RMI | No | No | Yes
Future RPC/RMI | No | No | Yes
Notifications (observer pattern) | No | No | Yes
Tuple spaces | Yes | Yes | Producer-side
Message queuing (Pull) | Yes | Yes | Producer-side
Publish/subscribe | Yes | Yes | Yes

#### The Siblings: Publish/subscribe variations

**Topic-based publish/subscribe.**

**Content-based publish/subscribe.**

**Type-based publish/subscribe.**

#### The Incarnations: Implementation issues

**Events.**

**The Media.**

**Qualities of Service.**




