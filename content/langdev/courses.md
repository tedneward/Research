title=Courses on Language Development
tags=language development,place,language
summary=A collection of links to (mostly academic) courses on how to build programming languages.
~~~~~~

- [301 - Organization of Programming Languages](https://www.youtube.com/watch?v=j2pYeKjq_60&list=PLB1enDd0fV0i5SWGe-A1YjmD8MmlGavIj&ab_channel=JayMcCarthy)
- [Accelerated 1](https://course.ccs.neu.edu/cs2500accelf17/index.html)
- [All the courses Matthias Felleisen teach](https://felleisen.org/matthias/teaching.html)
- [Benjamin Pierce - Software foundations](https://www.youtube.com/playlist?list=PLGCr8P_YncjUT7gXUVJWSoefQ40gTOz89)
- [CIS 341 - Compilers](https://www.seas.upenn.edu/~cis3410/20sp/)
- [CIS352 - Principles of Programming Languages](https://www.youtube.com/watch?v=2jrwXpUZW7k&list=PLXaqTeMx01E_eK1ZEpKvKL5KwSaj7cJW9&ab_channel=KristopherMicinski)
- [CMSC330 - Organization of Programming Languages](https://www.cs.umd.edu/class/spring2022/cmsc330/#schedule)
- [CMSC 430: Design and Implementation of Programming Languages](https://www.youtube.com/watch?v=KTWq1XAfuMQ&list=PLsg0tbEwZlcz0Xzv1rACy7xcQZiBcQ_iE&ab_channel=cmsc430)
- [CMU - CS6120 - Advanced Compilers](https://www.cs.cornell.edu/courses/cs6120/2022sp/lesson)
- [Compilers — Stanford](https://online.stanford.edu/courses/soe-ycscs1-compilers)
- [Compilers Design Recipe](https://soft.vub.ac.be/compilers/book_sec_recipe.html)
- [Compilers: Theory and Practice — Udacity](https://www.udacity.com/course/compilers-theory-and-practice--ud168)
- [Concepts in Programming Languages](https://www.cl.cam.ac.uk/teaching/1617/ConceptsPL/materials.html)
- [COP4020 - Programming Languages I](https://www.cs.ucf.edu/~leavens/COP4020/resources.shtml)
- [COS326 - Functional Programming](https://mediacentral.princeton.edu/channel/COS+326+Functional+Programming/174748251)
- [CS242: Programming Languages, Fall 2019](https://stanford-cs242.github.io/f19)
- [CS019 - Accelerated Introduction to Computer Science](https://cs.brown.edu/courses/cs019/2018/index.html)
- [CS164 Programming Languages and Compilers](https://www.bilibili.com/video/BV1NW411b79N?p=1)
- [CS242 - Programming Languages - Stanford](https://web.stanford.edu/class/cs242/coursework.html)
- [CS520 Theories of Programming Languages — KAIST](https://www.youtube.com/playlist?list=PLvV9DPeJV9xx0NegrG4gNu8WXSXibDICu)
- [CS2500 - Fundamentals of Computer Science](https://www.ccs.neu.edu/home/nderbinsky/fundies1/m1.html)
- [CS6120: Advanced Compilers: The Self-Guided Online Course](https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/): The work consists of reading papers and open-source hacking tasks, which use LLVM and an educational IR invented just for this class.
- [CSCI1730 - Programming Languages - Application and Interpretation](https://cs.brown.edu/courses/cs173/2012/Videos)
- [CSE 131 - Compiler Construction](https://podcast.ucsd.edu/watch/SP17/cse131_sp17/23)
- [CSE230 - Principles/Programming Languages](https://podcast.ucsd.edu/watch/fa18/cse230_b00/24)
- [Essentials of Programming Languages](http://proglang.informatik.uni-freiburg.de/teaching/proglang/2020ws)
- [Fundamentals 1](https://course.ccs.neu.edu/cs2500f16/index.html)
- [Fundamentals 2](https://course.ccs.neu.edu/cs2510)
- [Hack Your Own Language](https://felleisen.org/matthias/4620-s18/index.html)
- [History of Programming Languages](https://felleisen.org/matthias/7480-s17/index.html)
- [Indiana University Compiler Course](https://iu.mediaspace.kaltura.com/media/Compiler+Course/1_hwlujpzd)
- [Introduction to Compiler Construction](https://www.students.cs.ubc.ca/~cs-411/2020w2/index.html)
- [Jay McCarthy - 406 Compiler Construction](https://youtu.be/4tUj8BuC0qM)
- [LINFO1131 - Advanced programming language concepts](https://www.youtube.com/playlist?list=PLw454N-VXALROTZ_phkQ-D4QDU5w3x4R8)
- [Matthias Felleisen - Intensive Principles of Programming Languages](https://felleisen.org/matthias/7400-s14/Problem_Sets.html)
- [Matthias Felleisen - Principles of Programming Languages](https://felleisen.org/matthias/4400-s20/lectures.html) - in Racket
- [Principles of Compiler Design](https://www.bilibili.com/video/BV1qt41167uU?p=1)
- [Programming Language Foundations in Agda](https://cs.uwaterloo.ca/~plragde/747/notes/index.html)
- [Programming Languages and Logic](https://www.cs.cornell.edu/courses/cs4110/2021fa)
- [Programming Languages Course given by DCC-UFMG](https://hanielb.github.io/2021.2-lp)- text:["Modern Programming Languages: A Practical Introduction"](http://www.webber-labs.com/mpl/)
- [Programming Languages Ⅰ](https://www.coursera.org/learn/programming-languages-1)
- [Programming Languages Ⅱ](https://www.coursera.org/learn/programming-languages2)
- [Theory of Programming Language (Graduate course, Spr 2020)](http://staff.ustc.edu.cn/~yuzhang/tpl/2020s/index.html)

## Learning Paths

- [Advanced Programming Languages](http://di002.edv.uniovi.es/~labra/APL.html)
- [Compiler Engineer Path](http://dmitrysoshnikov.com/courses/compiler-engineer-path)
- [Learn Type Theory](https://github.com/jozefg/learn-tt)
- [Programming Language Theory Path](https://steshaw.org/plt)
- [So You Want to Be a (Compiler) Wizard](https://belkadan.com/blog/2016/05/So-You-Want-To-Be-A-Compiler-Wizard)

## Teaching/ExampleImplementations

* [Build Your Own Programming Language](https://github.com/PacktPublishing/Build-Your-Own-Programming-Language) (source)
* [Crafting Interpreters](http://craftinginterpreters.com/) by Bob Nystrom ([Github](https://github.com/munificent/craftinginterpreters)): A neo-classic book, walking through the construction of an interpreted language.

    * ["My Experience Crafting an Interpreter with Rust"](https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/): Book material ported to Rust.

* Creating the Bolt compiler (series):

    - [Source](https://github.com/mukul-rathi/bolt)
    - [Part 1: How I wrote my own "proper" programming language](https://mukulrathi.com/create-your-own-programming-language/intro-to-compiler/);
    - [Part 2: So how do you structure a compiler project?](https://mukulrathi.com/create-your-own-programming-language/compiler-engineering-structure/);
    - [Part 3: Writing a Lexer and Parser using OCamllex and Menhir](https://mukulrathi.com/create-your-own-programming-language/parsing-ocamllex-menhir/);
    - [Part 4: An accessible introduction to type theory and implementing a type-checker](https://mukulrathi.com/create-your-own-programming-language/intro-to-type-checking/);
    - [Part 5: A tutorial on liveness and alias dataflow analysis](https://mukulrathi.com/create-your-own-programming-language/data-race-dataflow-analysis/);
    - [Part 6: Desugaring - taking our high-level language and simplifying it!](https://mukulrathi.com/create-your-own-programming-language/lower-language-constructs-to-llvm/);
    - [Part 7: A Protobuf tutorial for OCaml and C++](https://mukulrathi.com/create-your-own-programming-language/protobuf-ocaml-cpp-tutorial/);
    - [Part 8: A Complete Guide to LLVM for Programming Language Creators](https://mukulrathi.com/create-your-own-programming-language/llvm-ir-cpp-api-tutorial/);
    - [Part 9: Implementing Concurrency and our Runtime Library](https://mukulrathi.com/create-your-own-programming-language/concurrency-runtime-language-tutorial/);
    - [Part 10: Generics - adding polymorphism to Bolt](https://mukulrathi.com/create-your-own-programming-language/generics-parametric-polymorphism/);
    - [Part 11: Adding Inheritance and Method Overriding to Our Language](https://mukulrathi.com/create-your-own-programming-language/inheritance-method-overriding-vtable/);

* [How to Compile Your Language](https://isuckatcs.github.io/how-to-compile-your-language/)
* [Language Incubator](https://github.com/EarlGray/language-incubator): Repo of language experiments/explorations; "An incubator/sandbox for learning compilers, interpreters, code generation, virtual machines, assemblers, JITs, etc."
* [Let's Build a Simple Interpreter](https://ruslanspivak.com/lsbasi-part1/): Up to 19 parts up through 2020.
* [mal](https://github.com/kanaka/mal) (Make A Lisp): Steps (and collection of implementations) to make your own Lisp.
* [Nanopass](https://legacy.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf): A framework for compiler education | [Source](https://github.com/nanopass/) in Racket or Scheme
* Subtype Inference by Example (series):

    - [Part 1: Introducing CubiML](https://blog.polybdenum.com/2020/07/04/subtype-inference-by-example-part-1-introducing-cubiml.html);
    - [Part 2: Parsing and Biunification](https://blog.polybdenum.com/2020/07/11/subtype-inference-by-example-part-2-parsing-and-biunification.html);
    - [Part 3: The Typechecker Frontend](https://blog.polybdenum.com/2020/07/18/subtype-inference-by-example-part-3-the-typechecker-frontend.html);
    - [Part 4: The Typechecker Core](https://blog.polybdenum.com/2020/07/25/subtype-inference-by-example-part-4-the-typechecker-core.html);
    - [Part 5: Incremental Reachability](https://blog.polybdenum.com/2020/08/01/subtype-inference-by-example-part-5-incremental-reachability.html);
    - [Part 6: Numeric Types and Operators](https://blog.polybdenum.com/2020/08/08/subtype-inference-by-example-part-6-numeric-types-and-operators.html);
    - [Part 7: Spanned Error Messages](https://blog.polybdenum.com/2020/08/15/subtype-inference-by-example-part-7-spanned-error-messages.html);
    - [Part 8: Mutability](https://blog.polybdenum.com/2020/08/22/subtype-inference-by-example-part-8-mutability.html);
    - [Part 9: Match Wildcards, Record Extension and Row Polymorphism](https://blog.polybdenum.com/2020/08/29/subtype-inference-by-example-part-9-nonexhaustive-matching-record-extensions-and-row-polymorphism.html);
    - [Part 10: Let Polymorphism](https://blog.polybdenum.com/2020/09/05/subtype-inference-by-example-part-10-let-polymorphism.html);
    - [Part 11: The Value Restriction and Polymorphic Recursion](https://blog.polybdenum.com/2020/09/19/subtype-inference-by-example-part-11-the-value-restriction.html);
    - [Part 12: Flow Typing and Mixed Comparison Operators](https://blog.polybdenum.com/2020/09/26/subtype-inference-by-example-part-12-flow-typing-and-mixed-comparison-operators.html);
    - [Part 13: Conditional Flow Constraints, Presence Polymorphism, and Type Level Computation](https://blog.polybdenum.com/2020/10/03/subtype-inference-by-example-part-13-conditional-flow-types-and-type-level-computation.html);
    - [Part 14: Type Annotations— What are they good for?](https://blog.polybdenum.com/2020/10/10/subtype-inference-by-example-part-14-type-annotation.html);
    - [Part 15: Monomorphic Type Annotations](https://blog.polybdenum.com/2020/10/17/subtype-inference-by-example-part-15-type-annotations.html);

* [Sudolang: A powerful programming language for LLMs](https://medium.com/javascript-scene/sudolang-a-powerful-pseudocode-programming-language-for-llms-d64d42aa719b)
* [The Super Tiny Compiler](https://github.com/jamiebuilds/the-super-tiny-compiler) (JS)
* [TinyML: A tiny functional language interpreter](https://d3s.mff.cuni.cz/files/teaching/nprg077/02-tinyml.pdf) (Tomas Petricek)
* [Write Yourself a Scheme in 48 Hours](https://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf)
* [Write Yourself a Scheme in 48 Hours using F#](https://write-yourself-a-scheme.pangwa.com/#/)
* [X-expressions in XMLisp: S-expressions and Extensible Markup Language Unite](https://home.cs.colorado.edu/~ralex/papers/PDF/X-expressions.pdf): "XMLisp unites S-expressions with XML into X-expressions that unify the notions of data sharing with computation. Using a combination of the Meta Object Protocol (MOP), readers and printers, X-expressions uniquely integrate XML at a language, not API level, into Lisp in a way that could not be done with other programming languages."


### Native/raw

* [AsmInterpreter](https://github.com/yekyam/AsmInterpreter): A simple assembly interpreter to help people with understanding the language without the hassle of setup.
* [Build your own Lisp](http://www.buildyourownlisp.com/contents) teaches C by building a Lisp.
* [luax](https://github.com/morrow1nd/luax): Lua-like programming language for studying compiler and interpreter courses.
* [Square](https://github.com/square-lang/Square): A tiny programming language under 200kb.
* [Writer your own C compiler from scratch with Python](https://medium.com/@pasi_pyrro/how-to-write-your-own-c-compiler-from-scratch-with-python-90ab84ffe071)

### LLVM

* [A Tutorial on How to Write a Compiler Using LLVM](https://tomassetti.me/a-tutorial-on-how-to-write-a-compiler-using-llvm/)
* [Implementing a JIT Compiled Language with Haskell and LLVM](https://www.stephendiehl.com/llvm/)
* [LLVM Tutorial: Kaleidoscope](https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html)
* [Writing your own toy language](https://gnuu.org/2009/09/18/writing-your-own-toy-compiler/) using flex, bison, LLVM; [code](https://github.com/lsegal/my_toy_compiler)
* [Mapping high level constructs to LLVM IR](https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/)
* [Kaleidoscope AST](https://ubiquitydotnet.github.io/Llvm.NET/v8.0.1/articles/Samples/Kaleidoscope-AST.html)

### CLR

* [Concatenative Thinking (wiki)](https://concatenative.org/wiki/view/Front%20Page): We are interested in both theoretical results and practical programming advice, especially as it pertains to any Concatenative language. We want to bring together disparate language communities and build a common knowledge repository that people can consult to learn more about this family of languages.
* Video - [Creating a domain specific language for .NET Application](https://www.youtube.com/watch?app=desktop&v=64x29FGaoK4)
* [How to Design Worlds (PDF)](https://world.cs.brown.edu/1/htdw-v1.pdf)
* Kaleidoscope: [Implementing a language with LLVM in CSharp](https://ice1000.org/llvm-cs/en/CSharpLangImpl01/): "By the end of the tutorial, we’ll have written a bit less than 1000 lines of non-comment, non-blank, lines of code. With this small amount of code, we’ll have built up a very reasonable compiler for a non-trivial language including a hand-written lexer, parser, AST, as well as code generation support with a JIT compiler. While other systems may have interesting “hello world" tutorials, I think the breadth of this tutorial is a great testament to the strengths of LLVM and why you should consider it if you’re interested in language or compiler design."
* [learn-programming-languages](https://github.com/jeanqasaur/learn-programming-languages): Resources for the working programmer to learn more about the fundamentals and theory of programming languages. (Jean Yang)
* Presentation - [Write your own domain specific language with F#](https://www.youtube.com/watch?app=desktop&v=NoGyFQ99NgY)

### JVM

* [joeq: A Virtual Machine and Compiler Infrastructure](https://joeq.sourceforge.net/) ([PDF](https://suif.stanford.edu/~jwhaley/papers/ivme03.pdf)) ([Source](https://sourceforge.net/projects/joeq/)): entirely implemented in Java, leading to greater reliability, portability, maintainability, and efficiency. It is also language-independent, so code from any supported language can be seamlessly compiled, linked, and executed --- all dynamically!
* Video - [Nashorn: implementing a dynamic language runtime on JVM](https://www.youtube.com/watch?v=KKaHkkpdHxg) (Attila Szegedi)
* [Scripting and Dynamic Interaction in Java](http://alumni.media.mit.edu/~mt/skij/dynjava/dynjava.html)
* [write_your_own_dynamic_language_runtime](https://github.com/forax/write_your_dynamic_language_runtime): How to write interpreters or dynamic compilers for dynamically typed languages on top of the JVM. This repository provides the basis to implement your own

    * Abstract Syntax Tree Interpreter
    * Stack based Interpreter
    * Java Virtual Machine based Interpreter

    of a dynamically typed language named smalljs which is almost a subset of JavaScript.

### Python

- [ast](https://docs.python.org/3/library/ast.html): The Python official documentation of the `ast` module that ships as part of Python. "The ast module helps Python applications to process trees of the Python abstract syntax grammar. The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like. An abstract syntax tree can be generated by passing ast.PyCF_ONLY_AST as a flag to the compile() built-in function, or using the parse() helper provided in this module. The result will be a tree of objects whose classes all inherit from ast.AST. An abstract syntax tree can be compiled into a Python code object using the built-in compile() function."

- [Code Transformer](https://github.com/danielzuegner/code-transformer): "The CodeTransformer is a Transformer based architecture that jointly learns from source code (Context) and parsed abstract syntax trees (AST; Structure). It does so by linking source code tokens to AST nodes and using pairwise distances (e.g., Shortest Paths, PPR) between the nodes to represent the AST. This combined representation is processed in the model by adding the contributions of each distance type to the raw self-attention score between two input tokens (See the paper for more details)."

- [CPython Internals](https://devguide.python.org/internals/exploring/)

- https://github.com/menezesd/epic-lang: interpreter for Python-like programming language with braces

- [Green Tree Snakes: The Missing Python AST docs](https://greentreesnakes.readthedocs.io/en/latest/index.html). Points out a few projects using the Python AST:

    - [pytest](https://docs.pytest.org/) (uses the AST to produce useful assertion error messages)
    - [astsearch](https://astsearch.readthedocs.io/) (search the semantics, not the syntax)
    - [astpath](https://github.com/hchasestevens/astpath) (XPath over an AST)
    - [bellybutton](https://github.com/hchasestevens/bellybutton) readily customised linter

- [(How to Write a (Lisp) Interpreter (in Python))](http://norvig.com/lispy.html): Norvig builds a simple Scheme in simple Python

- https://github.com/jonpry/Pill: Pill is an open source interpreter for the Cadence Skill language. Its purpose is to run PCell generator codes used in VLSI. Pill is written in Python and compiles the source into Python bytecode where it is then executed alongside regular python functions at similar speed to "native" python codes. *(This is an intriguing idea, and one that deserves some further exploration--if I can go from source to Py bytecode, we skip much of the parsing and get a startup speed benefit.)*

- https://github.com/jszheng/py3antlr4book: Covert ANTLR4 book source code to Python3 version.

- https://github.com/maxmalysh/tiny-py-interpreter: Python interpreter written in Python; uses ANTLR4

- Compiler Hacking (using [Chocopy](https://chocopy.org/))

    - Part 1: [Building a Compiler Front-end in Python](https://yangdanny97.github.io/blog/2020/05/29/chocopy-typechecker)
    - Part 2: [Building a JVM back-end](https://yangdanny97.github.io/blog/2021/08/26/chocopy-jvm-backend)
    - Part 3: [Building a CIL back-end](https://yangdanny97.github.io/blog/2022/05/22/chocopy-cil-backend)
    - Part 4: [Building a WASM back-end](https://yangdanny97.github.io/blog/2022/10/11/chocopy-wasm-backend)
    - Part 5: [Building a LLVM back-end](https://yangdanny97.github.io/blog/2023/07/18/chocopy-llvm-backend)

### Rust

- [Create Your Own Programming Language with Rust](https://createlang.rs/intro.html): Incomplete but interesting first steps
- [Make A Language](https://lunacookies.github.io/lang/):

    * [Part Twenty: Testing](https://lunacookies.github.io/lang/20/)
    * [Part Nineteen: Code Representations](https://lunacookies.github.io/lang/19/)
    * [Part Eighteen: Errors](https://lunacookies.github.io/lang/18/)
    * [Part Seventeen: Crates](https://lunacookies.github.io/lang/17/)
    * [Part Sixteen: Refactoring](https://lunacookies.github.io/lang/16/)
    * [Part Fifteen: Markers](https://lunacookies.github.io/lang/15/)
    * [Part Fourteen: Comments](https://lunacookies.github.io/lang/14/)
    * [Part Thirteen: Whitespace & Events](https://lunacookies.github.io/lang/13/)
    * [Part Twelve: Terminology](https://lunacookies.github.io/lang/12/)
    * [Part Eleven: Refinements](https://lunacookies.github.io/lang/11/)
    * [Part Ten: Starting Again](https://lunacookies.github.io/lang/10/)
    * [Part Nine: Function Calls](https://lunacookies.github.io/lang/9/)
    * [Part Eight: Function Definitions](https://lunacookies.github.io/lang/8/)
    * [Part Seven: A REPL](https://lunacookies.github.io/lang/7/)
    * [Part Six: Blocks](https://lunacookies.github.io/lang/6/)
    * [Part Five: Binding Usages](https://lunacookies.github.io/lang/5/)
    * [Part Four: Backtracking](https://lunacookies.github.io/lang/4/)
    * [Part Three: Defining Variables](https://lunacookies.github.io/lang/3/)
    * [Part Two: Whitespace Support](https://lunacookies.github.io/lang/2/)
    * [Part One: A Basic Parser](https://lunacookies.github.io/lang/1/)
    * [Part Zero: Getting set up](https://lunacookies.github.io/lang/0/)

### Go

[A simple Hindley-Milner type system in Go](https://github.com/chewxy/hm)

### Haskell

[Write You a Haskell](https://github.com/sdiehl/write-you-a-haskell)

### Learning/AI-related

- https://openreview.net/pdf?id=Xh5eMZVONGF : LANGUAGE-AGNOSTIC REPRESENTATION LEARNING OF SOURCE CODE FROM STRUCTURE AND CONTEXT

### Toy/experimental

- [Bhai](https://github.com/DulLabs/bhai-lang): A toy programming language written in Typescript
- [Dwarf](https://github.com/nicolasdilley/dwarf-interpreter): A very small scripting language written in Elixir.
- [Eval](https://github.com/tevelee/Eval): a lightweight interpreter framework written in Swift, evaluating expressions at runtime.
- https://github.com/yangtau/hedgehog: a toy programming language
- https://github.com/mattgreen/hython: Haskell-powered Python 3 interpreter
- Imp:

    - [IMP](https://github.com/jayconrod/imp-interpreter): A minimal interpreter for the toy language, IMP, used as an example for building interpreters.

    - https://github.com/nandor/utcn-imp: Imp Language and Interpreter

- https://github.com/proglangclass/interpreter: Language built during the Programming Language Masterclass.
- https://github.com/hisystems/Interpreter: Simple language interpreter written in pure C#.
- https://github.com/jamesdhutton/Interpreter: Interpreter for a simple language
- https://github.com/progschj/jtc: A toy programming language interpreter that has no dependencies and sits in a single C++ file. C++11 capable compilers should compile it without extra options other than enabling C++11.
- [Kaleidoscope](https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html): the classic from the LLVM website
- https://github.com/airtrack/luna: A toy interpreter of lua-like language
- [Maverick](https://github.com/willianscsilva/interpreter)
- https://github.com/hijkzzz/mini-interpreter: A simple scripting language (supports anonymous functions and clases)
- https://github.com/drmenguin/minilang-interpreter: Interpreter and Read-Eval-Print-Loop for a simple programming language called "MiniLang", written in C++
- https://github.com/JohnEarnest/ok: An open-source interpreter for the K5 programming language.
- https://github.com/oriontransfer/PL0-Language-Tools: An implementation of PL/0 including a tree-based interpreter and virtual machine. http://programming.dojo.net.nz/study/pl0-language-tools/index
- [Pointless](https://ptls.dev/) ([Source](https://github.com/pointless-lang/pointless)): a scripting language for learning and fun.
- https://github.com/bbu/simple-interpreter: A hackable and extensible lexer, parser and interpreter for a minimalistic, imperative, C-like language.
- https://github.com/totalspectrum/tinyscript
- https://github.com/sam-astro/Z-Sharp: Custom programming interpreter for ZSharp (Z#), a language I made up.

### Monkey
This is the language described by the book ["Writing an Interpreter in Go"](https://interpreterbook.com/). Also has a paired book, ["Writing a Compiler in Go"](https://compilerbook.com/) which appears to include the creation of a virtual machine for executing the compiled code.

* [Source](https://github.com/haifenghuang/monkey) (archived)
* [C++](https://github.com/zhuzilin/monkey)
* [C++](https://github.com/yhirose/monkey-cpp)
* [C++](https://github.com/Imymirror/mirror-monkey)
* Go: [Monkey in Go](https://github.com/bradford-hamilton/monkey-lang)
* [Haskell](https://github.com/hatashiro/monkey-hs)
* [Rust](https://github.com/Rydgel/monkey-rust)
* [Rust](https://github.com/wadackel/rs-monkey-lang)
* Rust: https://github.com/JoshMcguigan/monkey
* Rust: https://github.com/shuhei/cymbal
* Rust: https://github.com/hatashiro/monkey-rs
* Rust: [Monkey in Rust](https://github.com/bradford-hamilton/monkey_lang_rust)
* TypeScript: [Monkey in TypeScript](https://github.com/bradford-hamilton/monkey_lang_rust)
* [Gadget](https://github.com/vkandola/go-go-gadget): The 'Gadget' interpreter language, implemented in Go, using the Writing An Interpreter In Go book. This language is based off the Monkey interpreter language described in the book, and will be implemented as I progress through the book.

### Lox
From ["Crafting Interpreters"](http://www.craftinginterpreters.com/):

* C++: [CppLox](https://github.com/the-lambda-way/CppLox)
* Rust: [rlox](https://github.com/cwbriones/rlox)
* Swift: [slox](https://github.com/alexito4/slox)

### Esolangs

- https://github.com/nickdesaulniers/bf_interpreter_jit_compiler: Teach myself about interpreters, JITs, and compilers using the Brainfuck language as the toy language -- https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/
